import network
import time
import machine
from umqtt.simple import MQTTClient
from MPU6050 import MPU6050         #ACCELEROMETRO
from TCRT5000 import TCRT5000       #INFRAROSSI
from HCSR04 import HCSR04           #DISTANZA
import ssd1306
import framebuf

#CONFIGURAZIONE WI-FI
WIFI_NAME = 'iPhone di Chiara'
WIFI_PASSWORD = '23032004'

#CONFIGUARAZIONE MQTT
MQTT_BROKER = "172.19.159.125"      #IP PC
MQTT_CLIENT_ID = "esp32_caveau"
MQTT_TOPIC_STATUS = b"caveau/status"
MQTT_TOPIC_EVENTS = b"caveau/events"

led=Pin(4, Pin.OUT)

#CODICE 
SECRET_CODE = "2004"
UNLOCK_DOOR = 10 #secondi porta aperta

#BYTEARRAY LOGO
logo = bytearray([
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x20, 0x01, 0xfc, 0x06, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00, 0x07, 0xfc, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x1c, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x98, 0x01, 0x80, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x1c, 0x1e, 0x19, 0xff, 0xff, 0x80, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x0f, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0xe0, 0xc0, 0x0c, 0x00, 0x00, 0x30, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x01, 0xc3, 0x83, 0x04, 0x1f, 0x80, 0x30, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x03, 0x06, 0x0c, 0x07, 0xe1, 0x80, 0x60, 0x00, 0x60, 0x40, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x06, 0x0c, 0x38, 0x1c, 0x01, 0x80, 0x3c, 0x0c, 0x38, 0x60, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x0c, 0x00, 0x78, 0x00, 0x01, 0x80, 0x07, 0x07, 0x0c, 0x30, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x18, 0x01, 0x8c, 0x00, 0xff, 0xff, 0x01, 0xc1, 0x86, 0x18, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x18, 0x03, 0x06, 0x00, 0x80, 0x03, 0x80, 0xf0, 0xc3, 0x18, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x0e, 0x06, 0x03, 0x00, 0x00, 0x01, 0x80, 0xf8, 0x61, 0xe0, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x03, 0x8c, 0x01, 0x8c, 0x01, 0xf3, 0x01, 0x8c, 0x30, 0xc0, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x02, 0x78, 0x01, 0x87, 0xc0, 0x0f, 0x83, 0x86, 0x18, 0xc0, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x06, 0x30, 0x03, 0x07, 0x07, 0xe0, 0xe6, 0xc3, 0x38, 0x60, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x0c, 0x21, 0x06, 0x0c, 0x7f, 0xfe, 0x3c, 0x61, 0xe0, 0x30, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x0c, 0x63, 0x0c, 0x01, 0xff, 0xff, 0xc0, 0x30, 0xc0, 0x30, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x18, 0x42, 0x18, 0x07, 0xff, 0xff, 0xe0, 0x18, 0x40, 0x18, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x18, 0xc6, 0x10, 0x0f, 0xff, 0xff, 0xf0, 0x00, 0x60, 0x18, 0x40, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x10, 0x84, 0x31, 0x9f, 0xff, 0xff, 0xfd, 0x80, 0x20, 0x08, 0x40, 0x00, 0x00, 
0x00, 0x00, 0x06, 0x31, 0x8c, 0x61, 0x3f, 0xf8, 0x1f, 0xff, 0x00, 0x30, 0x00, 0x60, 0x00, 0x00, 
0x00, 0x00, 0x06, 0x31, 0x8c, 0x63, 0x7f, 0xf0, 0x0f, 0xfe, 0x00, 0x30, 0x80, 0x60, 0x00, 0x00, 
0x00, 0x00, 0x06, 0x30, 0x08, 0x42, 0x7f, 0xf0, 0x0f, 0xfe, 0x0e, 0x00, 0x80, 0x60, 0x00, 0x00, 
0x00, 0x00, 0x04, 0x20, 0x08, 0x42, 0x7f, 0xf0, 0x0f, 0xff, 0x7b, 0x00, 0xc0, 0x20, 0x00, 0x00, 
0x00, 0x00, 0x04, 0x20, 0x18, 0xc6, 0xff, 0xf0, 0x0f, 0xff, 0x03, 0x00, 0xc0, 0x20, 0x00, 0x00, 
0x00, 0x00, 0x04, 0x20, 0x18, 0xc4, 0xff, 0xfc, 0x3f, 0xff, 0x03, 0x00, 0xc0, 0x20, 0x00, 0x00, 
0x00, 0x00, 0x04, 0x20, 0x18, 0xc4, 0xff, 0xfc, 0x3f, 0xff, 0x03, 0x00, 0xc0, 0x20, 0x00, 0x00, 
0x00, 0x00, 0x04, 0x20, 0x18, 0xc6, 0xff, 0xfc, 0x3f, 0xff, 0x03, 0x00, 0xc0, 0x20, 0x00, 0x00, 
0x00, 0x00, 0x04, 0x20, 0x08, 0xc2, 0x7f, 0xfc, 0x3f, 0xff, 0x7f, 0x00, 0x80, 0x20, 0x00, 0x00, 
0x00, 0x00, 0x06, 0x30, 0x0f, 0x82, 0x7f, 0xfc, 0x3f, 0xfe, 0x0f, 0xff, 0xc0, 0x60, 0x00, 0x00, 
0x00, 0x00, 0x06, 0x31, 0x80, 0x03, 0x3f, 0xfc, 0x3f, 0xfe, 0x06, 0x01, 0xff, 0xe0, 0x00, 0x00, 
0x00, 0x00, 0x06, 0x01, 0x80, 0x01, 0x3f, 0xfe, 0x7f, 0xfc, 0x06, 0x01, 0x80, 0x60, 0x00, 0x00, 
0x00, 0x00, 0x02, 0x00, 0x80, 0x01, 0x9f, 0xff, 0xff, 0xf9, 0x0c, 0x01, 0x00, 0x40, 0x00, 0x00, 
0x00, 0x00, 0x03, 0x00, 0xc0, 0x03, 0x8f, 0xff, 0xff, 0xf3, 0x08, 0x03, 0x00, 0xc0, 0x00, 0x00, 
0x00, 0x00, 0x03, 0x00, 0x40, 0x1c, 0x07, 0xff, 0xff, 0xe6, 0x08, 0x02, 0x00, 0xc0, 0x00, 0x00, 
0x00, 0x00, 0x01, 0x80, 0x60, 0xe0, 0x01, 0xff, 0xff, 0x9c, 0x00, 0x86, 0x00, 0x80, 0x00, 0x00, 
0x00, 0x00, 0x01, 0x80, 0x33, 0x80, 0x0c, 0x7f, 0xfe, 0x38, 0x01, 0x8c, 0x01, 0x80, 0x00, 0x00, 
0x00, 0x00, 0x00, 0xc0, 0x1c, 0x00, 0x03, 0x80, 0x01, 0xcc, 0x03, 0x0c, 0x03, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0xc0, 0x18, 0x00, 0x40, 0xfc, 0x03, 0x06, 0x06, 0x00, 0x83, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x63, 0x0c, 0x01, 0xf0, 0x03, 0x80, 0x03, 0x0c, 0x00, 0x86, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x3f, 0x86, 0x03, 0x1c, 0x01, 0x80, 0x00, 0xf8, 0x01, 0x8c, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x18, 0xc3, 0x06, 0x03, 0xc1, 0x83, 0x80, 0xe0, 0x03, 0x0c, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x18, 0x70, 0xc0, 0x00, 0x3f, 0xfc, 0x01, 0x80, 0x06, 0x18, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x0c, 0x38, 0x60, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x0c, 0x30, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x06, 0x0c, 0x78, 0x00, 0x00, 0x00, 0x78, 0x0e, 0x30, 0x60, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x03, 0x07, 0xce, 0x03, 0xf8, 0x1f, 0xe0, 0x03, 0x60, 0xc0, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0xc3, 0x83, 0xc0, 0x0f, 0xf0, 0x30, 0x03, 0xc3, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x60, 0xe0, 0x70, 0x00, 0x00, 0x10, 0x07, 0xc6, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x38, 0x38, 0x1f, 0x80, 0x01, 0xf0, 0x1c, 0x7c, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x08, 0x0e, 0x00, 0xff, 0xff, 0x00, 0x70, 0x30, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x03, 0xc0, 0xe0, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x3e, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
])

#Tastierino
# Matrice tasti fisici
KEYS = [
    ["1","2","3","A"],
    ["4","5","6","B"],
    ["7","8","9","C"],
    ["*","0","#","D"]
]

# Pin ESP32 collegati alle righe fisiche del tastierino (output)
rows = [
    Pin(27, Pin.OUT),  # R1-8
    Pin(14, Pin.OUT),  # R2-7
    Pin(12, Pin.OUT),  # R3-6
    Pin(13, Pin.OUT)   # R4-5
]

# Pin ESP32 collegati alle colonne fisiche del tastierino (input_pullup)
cols = [
    Pin(26, Pin.IN, Pin.PULL_UP),  # C1-4
    Pin(25, Pin.IN, Pin.PULL_UP),  # C2-3
    Pin(33, Pin.IN, Pin.PULL_UP),  # C3-2
    Pin(32, Pin.IN, Pin.PULL_UP)   # C4-1
]

#STATI DEL CAVEAU
STATE_ARMED = 0  #sensori attivi
STATE_UNLOCKED = 1  #codice corretto, porta aperta
STATE_ALARM = 2     #allarme attivo

#INIZIALIZZAZIONE SENSORI

#LED e BUZZER
led_red = machine.Pin(15, machine.Pin.OUT)         #led per allarme
led_green = machine.Pin(2, machine.Pin.OUT)        #codice corretto
led_blue = machine.Pin(4, machine.Pin.OUT)         #connessione wi-fi riuscita 

buzzer = machine.Pin(5, machine.Pin.OUT)

#SERVO (PWM)
servo_pwm = machine.PWM(machine.Pin(18), freq=50)

def servo_set_angle(angle):
    # mappa 0-180° → duty ciclo (valori da calibrare sul tuo servo)
    min_duty = 40
    max_duty = 115
    duty = int(min_duty + (angle / 180.0) * (max_duty - min_duty))
    servo_pwm.duty(duty)

def servo_open():
    servo_set_angle(90)   # posizione "aperto" (da provare e correggere)

def servo_close():
    servo_set_angle(0)    # posizione "chiuso"

# IR - TCRT5000 SENSOR
sensor_ir = TCRT5000(pin=14, invert=True)

# I2C, OLED 
i2c = machine.I2C(0, scl=machine.Pin(22),
                     sda=machine.Pin(21))
oled = ssd1306.SSD1306_I2C(128, 64, i2c)

def oled_show_logo():
    fb = framebuf.FrameBuffer(logo, 128, 64, framebuf.MONO_HLSB)
    oled.fill(0)
    oled.blit(fb, 0, 0)  # logo fullscreen
    oled.show()
    
    #INSERISCI NEL MAIN - IL LOGO DEVE ESSERE MOSTRATO COME PRIMA COSA

# TASTIERINO
row_pins = [machine.Pin(p, machine.Pin.OUT) for p in KEYPAD_ROW_PINS]
col_pins = [machine.Pin(p, machine.Pin.IN, machine.Pin.PULL_DOWN) for p in KEYPAD_COL_PINS]

def read_keypad():
    for r in range(4):
        # Disattiva tutte le righe
        for rr in rows:
            rr.value(1)
        # Attiva solo la riga corrente
        rows[r].value(0)
        # Controlla le colonne
        for c in range(4):
            if cols[c].value() == 0:  # Tasto premuto
                time.sleep_ms(200)     # Anti-rimbalzo
                return KEYS[r][c]
    return None

#WI-FI + MQTT

# Connessione al wi-fi
def connect_wifi(timeout=10):
    oled_show("Connessione WiFi")
    led_blue.value(0)
    wlan = network.WLAN(network.STA_IF)
    wlan.active(True)
    wlan.connect(WIFI_NAME, WIFI_PASSWORD)

    start_time = time.time()
    while not wlan.isconnected():
        led_blue.value(1)
        time.sleep(0.2)
        led_blue.value(0)
        time.sleep(0.2)
        if time.time() - start_time > timeout:
            oled_show("Connessione fallita")
            return None

    led_blue.value(1)
    oled_show("WiFi connesso")
    return wlan

# Connessione all'MQTT
def connect_mqtt():
    # Creo un oggetto client
    client = MQTTClient(MQTT_CLIENT_ID, MQTT_BROKER)
    # Avvio la connessione TCP + Handshake MQTT col broker
    client.connect()
    oled_show("MQTT connesso")
    return client      #Restituisce l'oggetto client

# Publish
def mqtt_publish_status(client, status):    #status = oggetto che indica lo stato
    #pubblico un messaggio sul topic
    client.publish(MQTT_TOPIC_STATUS, status.encode())   #status.encode() -> converte le stringhe in byte

def mqtt_publish_event(client, event):
    client.publish(MQTT_TOPIC_EVENTS, event.encode())

# ACCELEROMETRO
accel = None
ACCEL_AVAILABLE = False

# Valore di riferimento (baseline) quando il caveau è fermo
baseline = None

# Soglia per decidere se un oggetto è stato spostato
MOVEMENT_THRESHOLD = 8000     # Puoi aumentare o diminuire questo valore

# ------------------------------------------------------------
# 1️⃣ INIZIALIZZAZIONE ACCELEROMETRO
# ------------------------------------------------------------
def init_accelerometer(i2c):
    """
    Inizializza il sensore MPU6050.
    Ritorna True se il sensore è collegato e funzionante.
    """
    global accel, ACCEL_AVAILABLE

    try:
        accel = MPU6050(i2c)
        ACCEL_AVAILABLE = True
        print("MPU6050 rilevato correttamente.")
    except Exception as e:
        ACCEL_AVAILABLE = False
        print("ERRORE: MPU6050 non trovato.", e)

    return ACCEL_AVAILABLE

# ------------------------------------------------------------
# 2️⃣ CALIBRAZIONE (FOTO INIZIALE DELLO STATO FERMO)
# ------------------------------------------------------------
def calibrate_accel():
    """
    Legge i valori X, Y, Z quando tutto è fermo
    e li salva come baseline.
    """
    global baseline

    if not ACCEL_AVAILABLE:
        print("Impossibile calibrare: accelerometro non disponibile.")
        return

    vals = accel.get_values()
    baseline = (vals['AcX'], vals['AcY'], vals['AcZ'])

    print("Baseline accelerometro impostata a:", baseline)

# ------------------------------------------------------------
# 3️⃣ RILEVAZIONE MOVIMENTO
# ------------------------------------------------------------
def movement_detected():
    """
    Ritorna True se il vaso/quadro è stato spostato.
    Ritorna False se tutto è fermo.
    """

    # Se non c'è accelerometro → nessun movimento
    if not ACCEL_AVAILABLE:
        return False

    # Se la baseline non è stata ancora impostata
    if baseline is None:
        return False

    # Legge valori attuali
    vals = accel.get_values()

    # Calcola differenze rispetto alla baseline
    dx = abs(vals['AcX'] - baseline[0])
    dy = abs(vals['AcY'] - baseline[1])
    dz = abs(vals['AcZ'] - baseline[2])

    total = dx + dy + dz

    # Debug (puoi disattivarlo se spam troppo)
    # print("dx:", dx, "dy:", dy, "dz:", dz, "total:", total)

    # Decide se c'è movimento
    return total > MOVEMENT_THRESHOLD