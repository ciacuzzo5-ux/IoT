import network
import time
import machine
from umqtt.simple import MQTTClient
from mpu6050 import MPU6050
import ssd1306
import framebuf

#CONFIGURAZIONE WI-FI
WIFI_NAME = 'iPhone di Chiara'
WIFI_PASSWORD = '23032004'

MQTT_BROKER = "172.19.159.125"      #IP PC
MQTT_CLIENT_ID = "esp32_caveau"
MQTT_TOPIC_STATUS = b"caveau/status"
MQTT_TOPIC_EVENTS = b"caveau/events"

#CODICE 
SECRET_CODE = "2004"
UNLOCK_DOOR = 10 #secondi porta aperta

#BYTEARRAY LOGO
logo = bytearray([
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x20, 0x01, 0xfc, 0x06, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00, 0x07, 0xfc, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x1c, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x98, 0x01, 0x80, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x1c, 0x1e, 0x19, 0xff, 0xff, 0x80, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x0f, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0xe0, 0xc0, 0x0c, 0x00, 0x00, 0x30, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x01, 0xc3, 0x83, 0x04, 0x1f, 0x80, 0x30, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x03, 0x06, 0x0c, 0x07, 0xe1, 0x80, 0x60, 0x00, 0x60, 0x40, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x06, 0x0c, 0x38, 0x1c, 0x01, 0x80, 0x3c, 0x0c, 0x38, 0x60, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x0c, 0x00, 0x78, 0x00, 0x01, 0x80, 0x07, 0x07, 0x0c, 0x30, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x18, 0x01, 0x8c, 0x00, 0xff, 0xff, 0x01, 0xc1, 0x86, 0x18, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x18, 0x03, 0x06, 0x00, 0x80, 0x03, 0x80, 0xf0, 0xc3, 0x18, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x0e, 0x06, 0x03, 0x00, 0x00, 0x01, 0x80, 0xf8, 0x61, 0xe0, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x03, 0x8c, 0x01, 0x8c, 0x01, 0xf3, 0x01, 0x8c, 0x30, 0xc0, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x02, 0x78, 0x01, 0x87, 0xc0, 0x0f, 0x83, 0x86, 0x18, 0xc0, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x06, 0x30, 0x03, 0x07, 0x07, 0xe0, 0xe6, 0xc3, 0x38, 0x60, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x0c, 0x21, 0x06, 0x0c, 0x7f, 0xfe, 0x3c, 0x61, 0xe0, 0x30, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x0c, 0x63, 0x0c, 0x01, 0xff, 0xff, 0xc0, 0x30, 0xc0, 0x30, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x18, 0x42, 0x18, 0x07, 0xff, 0xff, 0xe0, 0x18, 0x40, 0x18, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x18, 0xc6, 0x10, 0x0f, 0xff, 0xff, 0xf0, 0x00, 0x60, 0x18, 0x40, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x10, 0x84, 0x31, 0x9f, 0xff, 0xff, 0xfd, 0x80, 0x20, 0x08, 0x40, 0x00, 0x00, 
0x00, 0x00, 0x06, 0x31, 0x8c, 0x61, 0x3f, 0xf8, 0x1f, 0xff, 0x00, 0x30, 0x00, 0x60, 0x00, 0x00, 
0x00, 0x00, 0x06, 0x31, 0x8c, 0x63, 0x7f, 0xf0, 0x0f, 0xfe, 0x00, 0x30, 0x80, 0x60, 0x00, 0x00, 
0x00, 0x00, 0x06, 0x30, 0x08, 0x42, 0x7f, 0xf0, 0x0f, 0xfe, 0x0e, 0x00, 0x80, 0x60, 0x00, 0x00, 
0x00, 0x00, 0x04, 0x20, 0x08, 0x42, 0x7f, 0xf0, 0x0f, 0xff, 0x7b, 0x00, 0xc0, 0x20, 0x00, 0x00, 
0x00, 0x00, 0x04, 0x20, 0x18, 0xc6, 0xff, 0xf0, 0x0f, 0xff, 0x03, 0x00, 0xc0, 0x20, 0x00, 0x00, 
0x00, 0x00, 0x04, 0x20, 0x18, 0xc4, 0xff, 0xfc, 0x3f, 0xff, 0x03, 0x00, 0xc0, 0x20, 0x00, 0x00, 
0x00, 0x00, 0x04, 0x20, 0x18, 0xc4, 0xff, 0xfc, 0x3f, 0xff, 0x03, 0x00, 0xc0, 0x20, 0x00, 0x00, 
0x00, 0x00, 0x04, 0x20, 0x18, 0xc6, 0xff, 0xfc, 0x3f, 0xff, 0x03, 0x00, 0xc0, 0x20, 0x00, 0x00, 
0x00, 0x00, 0x04, 0x20, 0x08, 0xc2, 0x7f, 0xfc, 0x3f, 0xff, 0x7f, 0x00, 0x80, 0x20, 0x00, 0x00, 
0x00, 0x00, 0x06, 0x30, 0x0f, 0x82, 0x7f, 0xfc, 0x3f, 0xfe, 0x0f, 0xff, 0xc0, 0x60, 0x00, 0x00, 
0x00, 0x00, 0x06, 0x31, 0x80, 0x03, 0x3f, 0xfc, 0x3f, 0xfe, 0x06, 0x01, 0xff, 0xe0, 0x00, 0x00, 
0x00, 0x00, 0x06, 0x01, 0x80, 0x01, 0x3f, 0xfe, 0x7f, 0xfc, 0x06, 0x01, 0x80, 0x60, 0x00, 0x00, 
0x00, 0x00, 0x02, 0x00, 0x80, 0x01, 0x9f, 0xff, 0xff, 0xf9, 0x0c, 0x01, 0x00, 0x40, 0x00, 0x00, 
0x00, 0x00, 0x03, 0x00, 0xc0, 0x03, 0x8f, 0xff, 0xff, 0xf3, 0x08, 0x03, 0x00, 0xc0, 0x00, 0x00, 
0x00, 0x00, 0x03, 0x00, 0x40, 0x1c, 0x07, 0xff, 0xff, 0xe6, 0x08, 0x02, 0x00, 0xc0, 0x00, 0x00, 
0x00, 0x00, 0x01, 0x80, 0x60, 0xe0, 0x01, 0xff, 0xff, 0x9c, 0x00, 0x86, 0x00, 0x80, 0x00, 0x00, 
0x00, 0x00, 0x01, 0x80, 0x33, 0x80, 0x0c, 0x7f, 0xfe, 0x38, 0x01, 0x8c, 0x01, 0x80, 0x00, 0x00, 
0x00, 0x00, 0x00, 0xc0, 0x1c, 0x00, 0x03, 0x80, 0x01, 0xcc, 0x03, 0x0c, 0x03, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0xc0, 0x18, 0x00, 0x40, 0xfc, 0x03, 0x06, 0x06, 0x00, 0x83, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x63, 0x0c, 0x01, 0xf0, 0x03, 0x80, 0x03, 0x0c, 0x00, 0x86, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x3f, 0x86, 0x03, 0x1c, 0x01, 0x80, 0x00, 0xf8, 0x01, 0x8c, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x18, 0xc3, 0x06, 0x03, 0xc1, 0x83, 0x80, 0xe0, 0x03, 0x0c, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x18, 0x70, 0xc0, 0x00, 0x3f, 0xfc, 0x01, 0x80, 0x06, 0x18, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x0c, 0x38, 0x60, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x0c, 0x30, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x06, 0x0c, 0x78, 0x00, 0x00, 0x00, 0x78, 0x0e, 0x30, 0x60, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x03, 0x07, 0xce, 0x03, 0xf8, 0x1f, 0xe0, 0x03, 0x60, 0xc0, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0xc3, 0x83, 0xc0, 0x0f, 0xf0, 0x30, 0x03, 0xc3, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x60, 0xe0, 0x70, 0x00, 0x00, 0x10, 0x07, 0xc6, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x38, 0x38, 0x1f, 0x80, 0x01, 0xf0, 0x1c, 0x7c, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x08, 0x0e, 0x00, 0xff, 0xff, 0x00, 0x70, 0x30, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x03, 0xc0, 0xe0, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x3e, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
])

#Tastierino
KEYPAD_ROW_PINS = [13, 12, 14, 27]
KEYPAD_COL_PINS = [26, 25, 33, 32]

KEYPAD_MAP = [
    ['1','2','3','A'],
    ['4','5','6','B'],
    ['7','8','9','C'],
    ['*','0','#','D']
]

#STATI DEL CAVEAU
STATE_ARMED = 0  #sensori attivi
STATE_UNLOCKED = 1  #codice corretto, porta aperta
STATE_ALARM = 2     #allarme attivo

#INIZIALIZZAZIONE SENSORI

#LED e BUZZER
led_red = machine.Pin(15, machine.Pin.OUT)         #led per allarme
led_green = machine.Pin(2, machine.Pin.OUT)        #codice corretto
led_blue = machine.Pin(4, machine.Pin.OUT)         #connessione wi-fi riuscita 

buzzer = machine.Pin(5, machine.Pin.OUT)

#SERVO (PWM)
servo_pwm = machine.PWM(machine.Pin(18), freq=50)

def servo_set_angle(angle):
    # mappa 0-180° → duty ciclo (valori da calibrare sul tuo servo)
    min_duty = 40
    max_duty = 115
    duty = int(min_duty + (angle / 180.0) * (max_duty - min_duty))
    servo_pwm.duty(duty)

def servo_open():
    servo_set_angle(90)   # posizione "aperto" (da provare e correggere)

def servo_close():
    servo_set_angle(0)    # posizione "chiuso"

# IR SENSOR
ir_sensor = machine.Pin(19, machine.Pin.IN)

# I2C, OLED 
i2c = machine.I2C(0, scl=machine.Pin(22),
                     sda=machine.Pin(21))
oled = ssd1306.SSD1306_I2C(128, 64, i2c)

def oled_show_logo():
    fb = framebuf.FrameBuffer(logo, 128, 64, framebuf.MONO_HLSB)
    oled.fill(0)
    oled.blit(fb, 0, 0)  # logo fullscreen
    oled.show()
    
    #INSERISCI NEL MAIN - IL LOGO DEVE ESSERE MOSTRATO COME PRIMA COSA

# TASTIERINO
row_pins = [machine.Pin(p, machine.Pin.OUT) for p in KEYPAD_ROW_PINS]
col_pins = [machine.Pin(p, machine.Pin.IN, machine.Pin.PULL_DOWN) for p in KEYPAD_COL_PINS]

def scan_keypad():
    """Ritorna il tasto premuto (o None se nessuno)"""
    for r, row in enumerate(row_pins):
        row.value(1)       # attivo una riga
        for c, col in enumerate(col_pins):
            if col.value() == 1:   # se su quella colonna arriva tensione
                key = KEYPAD_MAP[r][c]   
                row.value(0)
                return key    #tasto premuto
        row.value(0)
    return None

#WI-FI + MQTT

# Connessione al wi-fi
def connect_wifi():
    oled_show("Connessione WiFi")            #scrivo sull'oled la scritta di connessione
    led_blue.value(0)                        #all'inizio il led è spento
    wlan = network.WLAN(network.STA_IF)      #oggetto wlanv-> interfaccia wi-fi esp32 in modalità client -> serve per collegarsi al router
    wlan.active(True)                        #attiva fisicamente la scheda wi-fi dell'esp
    wlan.connect(WIFI_NAME, WIFI_PASSWORD)   #avvia la connessione alla rete wi-fi indicata

    #ciclo per connettersi al wi-fi
    while not wlan.isconnected():  #Finchè isconnected()==FALSE si ripete il ciclo
        #Il led blu lampeggia mentre il microcontrollore si connette
        led_blue.value(1)
        time.sleep(0.2)
        led_blue.value(0)
        time.sleep(0.2)

    #L'esp è connessa al wi-fi
    led_blue.value(1)  # fisso = connesso -> led acceso per tutta la sessione
    oled_show("WiFi connesso")
    return wlan

# Connessione all'MQTT
def connect_mqtt():
    # Creo un oggetto client
    client = MQTTClient(MQTT_CLIENT_ID, MQTT_BROKER)
    # Avvio la connessione TCP + Handshake MQTT col broker
    client.connect()
    oled_show("MQTT connesso")
    return client      #Restituisce l'oggetto client

# Publish
def mqtt_publish_status(client, status):    #status = oggetto che indica lo stato
    #pubblico un messaggio sul topic
    client.publish(MQTT_TOPIC_STATUS, status.encode())   #status.encode() -> converte le stringhe in byte

def mqtt_publish_event(client, event):
    client.publish(MQTT_TOPIC_EVENTS, event.encode())

# ACCELEROMETRO
accel = None
ACCEL_AVAILABLE = False

# Valore di riferimento (baseline) quando il caveau è fermo
baseline = None

# Soglia per decidere se un oggetto è stato spostato
MOVEMENT_THRESHOLD = 8000     # Puoi aumentare o diminuire questo valore

# ------------------------------------------------------------
# 1️⃣ INIZIALIZZAZIONE ACCELEROMETRO
# ------------------------------------------------------------
def init_accelerometer(i2c):
    """
    Inizializza il sensore MPU6050.
    Ritorna True se il sensore è collegato e funzionante.
    """
    global accel, ACCEL_AVAILABLE

    try:
        accel = MPU6050(i2c)
        ACCEL_AVAILABLE = True
        print("MPU6050 rilevato correttamente.")
    except Exception as e:
        ACCEL_AVAILABLE = False
        print("ERRORE: MPU6050 non trovato.", e)

    return ACCEL_AVAILABLE

# ------------------------------------------------------------
# 2️⃣ CALIBRAZIONE (FOTO INIZIALE DELLO STATO FERMO)
# ------------------------------------------------------------
def calibrate_accel():
    """
    Legge i valori X, Y, Z quando tutto è fermo
    e li salva come baseline.
    """
    global baseline

    if not ACCEL_AVAILABLE:
        print("Impossibile calibrare: accelerometro non disponibile.")
        return

    vals = accel.get_values()
    baseline = (vals['AcX'], vals['AcY'], vals['AcZ'])

    print("Baseline accelerometro impostata a:", baseline)

# ------------------------------------------------------------
# 3️⃣ RILEVAZIONE MOVIMENTO
# ------------------------------------------------------------
def movement_detected():
    """
    Ritorna True se il vaso/quadro è stato spostato.
    Ritorna False se tutto è fermo.
    """

    # Se non c'è accelerometro → nessun movimento
    if not ACCEL_AVAILABLE:
        return False

    # Se la baseline non è stata ancora impostata
    if baseline is None:
        return False

    # Legge valori attuali
    vals = accel.get_values()

    # Calcola differenze rispetto alla baseline
    dx = abs(vals['AcX'] - baseline[0])
    dy = abs(vals['AcY'] - baseline[1])
    dz = abs(vals['AcZ'] - baseline[2])

    total = dx + dy + dz

    # Debug (puoi disattivarlo se spam troppo)
    # print("dx:", dx, "dy:", dy, "dz:", dz, "total:", total)

    # Decide se c'è movimento
    return total > MOVEMENT_THRESHOLD